namespace ReflectionIT.DisposeGenerator;

public static class SourceGenerationHelper {

    internal static string ImplementDisposablePattern(DisposableToGenerate classToGenerate) {
        ICsFileBuilder csFileBuilder = new CsFileBuilder();

        csFileBuilder.AddAutoGeneratedHeader("ReflectionIT.DisposeGenerator")
                     .AddEmptyLine();

        if (classToGenerate.ImplementIAsyncDisposable) {
            csFileBuilder.AddStatements("#nullable enable")
                         .AddEmptyLine()
                         .AddUsing("ValueTaskAlias = global::System.Threading.Tasks.ValueTask")
                         .AddEmptyLine();
        }

        csFileBuilder.AddNamespace(classToGenerate.Namespace, true);

        GenerateBaseImplementation(csFileBuilder, classToGenerate);

        if (classToGenerate.ImplementDisposable) {
            GenerateDisposableImplementation(csFileBuilder, "IDisposable", false, classToGenerate);
        }

        if (classToGenerate.ImplementIAsyncDisposable) {
            GenerateDisposableImplementation(csFileBuilder, "IAsyncDisposable", true, classToGenerate);
        }

        csFileBuilder.EndNamespace();

        return csFileBuilder.Build();
    }

    private static void GenerateBaseImplementation(ICsFileBuilder builder, DisposableToGenerate classToGenerate) {
        builder.AddStatementAndStartBlock($"partial class {classToGenerate.Name}")
               .AddStatements("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]",
                                    "private bool _isDisposed = false;")
               .AddProtectedDisposed(classToGenerate.IsSealed)
               .AddEmptyLine()
               .AddFinializer(classToGenerate.HasUnmangedResources, classToGenerate.Name, !classToGenerate.ImplementDisposable && classToGenerate.ImplementIAsyncDisposable)
               .EndBlock()
               .AddEmptyLine();
    }

    private static void GenerateDisposableImplementation(ICsFileBuilder builder, string interfaceName, bool isAsync, DisposableToGenerate classToGenerate) {
        builder.AddStatementAndStartBlock($"partial class {classToGenerate.Name} : global::System.{interfaceName}")
               //.AddCallbackFunctions(isAsync, classToGenerate)
               .AddDisposeBoolean(isAsync, classToGenerate)
               .AddEmptyLine()
               .AddDispose(isAsync)
               .EndBlock()
               .AddEmptyLine();
    }

    private static ICsFileBuilder AddProtectedDisposed(this ICsFileBuilder builder, bool isSealed) {
        string accessModifier = isSealed ? "private" : "protected";
        builder.AddStatements($"{accessModifier} bool IsDisposed => _isDisposed;");
        return builder;
    }

    private static ICsFileBuilder AddDispose(this ICsFileBuilder builder, bool isAsync) {
        if (isAsync == false) {
            builder.AddStatementAndStartBlock("public void Dispose()")
                   .AddStatements("Dispose(true);");
            builder.AddStatements("global::System.GC.SuppressFinalize(this);")
                   .EndBlock();
        } else {
            //builder.AddStatementAndStartBlock("public async ValueTaskAlias DisposeAsync()")
            //       .AddStatements("await DisposeAsync(true);");
        }

        return builder;
    }

    private static ICsFileBuilder AddFinializer(this ICsFileBuilder builder, bool hasUnmanagedResources, string className, bool isAsync) {
        if (hasUnmanagedResources && !isAsync) {

            builder.AddStatementAndStartBlock($"~{className}()")
                   .AddStatements("Dispose(false);")
                   .EndBlock();
        }

        return builder;
    }

    private static ICsFileBuilder AddDisposeBoolean(this ICsFileBuilder builder,
        bool isAsync,
        DisposableToGenerate disposableToGenerate) {
        if (isAsync) {
            builder.AddDisposeAsyncBooleanLogic(disposableToGenerate);
        } else {
            builder.AddDisposeBooleanLogic(disposableToGenerate);
        }

        return builder;
    }

    private static void AddDisposeBooleanLogic(this ICsFileBuilder builder, DisposableToGenerate disposableToGenerate) {
        string methodPrefix = disposableToGenerate.IsSealed ? "private" : "protected virtual";
        string[] variablesName = disposableToGenerate.FieldsOrProperties
            .Select(x => GetDisposeStatement(x, false)).ToArray();

        builder.AddStatementAndStartBlock($"{methodPrefix} void Dispose(bool disposing)")
               .AddIfBlock("IsDisposed", "return;")
               .AddStatements("", "OnDisposing(disposing);")
               .AddEmptyLine()
               .AddStatementAndStartBlock("if (disposing)")
               .AddStatements(variablesName)
               .EndBlock()
               .AddStatements("", "OnDisposed(disposing);")
               .AddStatements("", "_isDisposed = true;")
               .EndBlock();

        builder.AddStatements($"partial void OnDisposing(bool disposing);");
        builder.AddStatements($"partial void OnDisposed(bool disposing);");

    }

    private static void AddDisposeAsyncBooleanLogic(this ICsFileBuilder builder, DisposableToGenerate disposableToGenerate) {
        //string methodPrefix = disposableToGenerate.IsSealed ? "private" : "protected virtual";
        string[] variablesName = disposableToGenerate.FieldsOrProperties
            .Select(x => GetDisposeStatement(x, true)).ToArray();


        builder.AddStatementAndStartBlock($"public async ValueTaskAlias DisposeAsync()")
               //.AddIfBlock("_isDisposed", "return ValueTaskAlias.FromResult(ValueTaskAlias.CompletedTask);")
               .AddStatementAndStartBlock("if (!IsDisposed)")
               .AddEmptyLine()
               .AddStatementsIf(disposableToGenerate.GenerateOnDisposingAsync, "", "await OnDisposingAsync();")
               .AddStatements(variablesName)
               .AddStatementsIf(disposableToGenerate.GenerateOnDisposedAsync, "", "await OnDisposedAsync();")
               .AddStatements("", "_isDisposed = true;")
               .EndBlock()
               .EndBlock();

        if (disposableToGenerate.GenerateOnDisposingAsync) {
            builder.AddStatements($"private partial ValueTaskAlias OnDisposingAsync();");
        }

        if (disposableToGenerate.GenerateOnDisposedAsync) {
            builder.AddStatements($"private partial ValueTaskAlias OnDisposedAsync();");
        }


    }

    public static string GetDisposeStatement(FieldOrPropertyToDispose fieldOrProperty, bool isAsync) {
        string needAwait = isAsync && fieldOrProperty.ImplementIAsyncDisposable ? "await" : string.Empty;
        string needAsync = isAsync && fieldOrProperty.ImplementIAsyncDisposable ? "Async" : string.Empty;

        string disposeStatement = string.Empty;

        disposeStatement = fieldOrProperty.Type.IsValueType
            ? $"{needAwait} {fieldOrProperty.Name}.Dispose{needAsync}();"
            : $"""
                if ({fieldOrProperty.Name} is global::{fieldOrProperty.Type} @object) {needAwait} @object.Dispose{needAsync}(); 
                """;

        string setToNullStatement = fieldOrProperty.SetToNull ? $"{fieldOrProperty.Name} = null;" : "";

        return $"{disposeStatement}{setToNullStatement}";
    }

#pragma warning disable IDE1006 // Naming Styles
    private const string Header = """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by the ReflectionIT.DisposeGenerator source generator
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------

        #nullable enable
        """;
#pragma warning restore IDE1006 // Naming Styles

    public const string Attribute = Header + """

        #if DISPOSER_GENERATORS_EMBED_ATTRIBUTES
        
        namespace ReflectionIT.DisposeGenerator.Attributes {

            /// <summary>
            /// Implementing <see cref="System.IDisposable"/>System.IDisposable</see> interface in the recommended way.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
            public class DisposableAttribute : Attribute
            {
                public bool HasUnmangedResources { get; set; }
            }

            /// <summary>
            /// Implementing <see cref="System.IAsyncDisposable"/>System.IAsyncDisposable</see> interface in the recommended way.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
            public sealed class AsyncDisposableAttribute : global::System.Attribute
            {
                /// <summary>
                /// Generate OnDisposingAsync() partial method which is called at the start of DisposeAsync().
                /// </summary>
                public bool GenerateOnDisposingAsync { get; set; }

                /// <summary>
                /// Generate GenerateOnDisposedAsync partial method which is called at the end of DisposeAsync().
                /// </summary>
                public bool GenerateOnDisposedAsync { get; set; }
            }

            [global::System.AttributeUsage(global::System.AttributeTargets.Field | global::System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
            public class CascadeDisposeAttribute : global::System.Attribute
            {
                public bool Ignore { get; set; } 
                public bool SetToNull { get; set; }
            }
        }
        #endif
        """;

}